# Exceptions

## Basic Idea

Базовая идея - не хочется, чтобы весь сервер падал при ошибке в одном месте программы. 
Можно реализовать, передавая в функцию третьим параметром фиктивный указатель, который 
меняется в зависимости от того, отработала ли функция кореектно или нет. Так и было сделано 
в чистом C. А давайте вместо этого добавим новый способ выхода из функции - выбрасывание 
исключения: оператор throw 

```c++
int f(int x, int y) {
    if (y == 0){
        throw 1;
    } else {
        return x / y;
    }
}
```
Если вызвать этот код, то произойдёт RE, но уже не с ошибками `Segmentation Fault` или 
`Floating Point Exception`, а `Terminate called after throwing an instance of ...`. `Terminate` - 
функция, которая вызывается в случае того, что программе нужно аварийно завершиться. Запись выше
означает, что была выброшена ошибка типа `int`, которая не была поймана. Чтобы словить исключение, 
нужно обернуть подозреваемый код в блок `try` :

```c++
try {
    f(1, 0);
} catch (int x) {
    std::cout << "AAA\n";
}
```
Тогда программа выведет `AAA`, но завершится удачно. Работает это так: Если внутри `try` не 
происходит выбрасывания исключения, то `catch` пропускается и код продолжает выполняться. Иначе 
ловится исключения и исполняется блок `catch`. Это работает, только если ошибка - исключение, 
брошенное с помощью `throw`. В `catch` нельзя использовать шаблоны. Можно пистаь ещё и так:
```c++
try {} catch (...) {}
```
Тогда поймается исключение любого типа.

## Difference beetween Runtime Errors and Exceptions

Не любое RE является исключением: например, деление на 0. С помощью `try-catch` можно поймать
только то, что брошено с помощью `throw`. Ни выход за границу массива, ни ошибки компиляции
не ловятся с помощью `try-catch`. А в `python` можно. А потому что эффективность. В `std` 
есть некоторые функции, бросающие исключение. Например, неудачный `dynamic_cast` выбрасывает
исключение типа `std::bad_cast`, а неудачный `new`, при невозмодности выделить нужную память,
выбрасывает `std::bad_alloc`. Есть ещё такой тип ошибки - `std::out_of_range`. Она выбрасывается,
если к элементу контейнера по невалидному индексу обращаются с помощью метода `.at()`, вместо 
использования `[]`. Например, так:
```c++
std::vector<int> v = {1, 2, 3, 4, 5};
try {
    std::cout << v.at(100) << std::endl;
} catch (std::out_of_range) {
    std::cout << "Index out of range :(" << std::endl;
}
```

В `C++` существует стандартная иерархия ошибок: в стандартной библиотеке есть набор типов, 
исключения которых нужно бросать. Их список можно посмотреть на [сайте](https://en.cppreference.com/w/cpp/error/exception).
Некоторые из выписанных классов являются наследниками других. 


В стандартной библиотеке есть тип `std::runtime_error`. Это запутывает, но это не значит, что
любой RE, как мы уже разобрались, является исключением. Страуструп удачно выбрал название. 


Зачем это нужно? У всех исключений из `std::` можно вызвать метод `what`: 
```c++
std::vector<int> v = {1, 2, 3};
try {
    v.at(100) = 100;
} catch (std::exception& ex) {
    std::cout << ex.what() << std::endl;
}
```
Чтобы самому изменить содержание сообщения `what()` можно пользоваться конструктором исключения:
```c++
throw std::out_of_range("if you stare into the abyss, the abyss stares back at you");
```

## Rules of exception catching


1. В `catch` не производится почти никаких привидений типов:
```c++
try {
    throw '1';
} catch (int x){
    std::cout << "Not caught";
}
```
Не работает даже так:
```c++
try {
    throw 1;
} catch (unsigned int x){
    std::cout << "Not caught :(";
}
```
Единственное разрешённое привидение типов - между сыном и наследником и между `const` и отсутствием 
`const`. 

2. Если есть несколько `catch`, то выбирается первая подходящая и дальнейшие `catch` не производятся. 

```c++
try {
    throw std::out_of_range("aaaa");
} catch (std::exception& ex) {
    std::cout << 1;
    //throw 1;
} catch (std::out_of_range& oor){
    std::cout << 2;
} catch (...) {
    std::cout << 3;
}
```
Даже если раскомментировать закомментированную строчку, то брошенное исключение не поймается следующими
`catch`.


## Exceptions and copying
Заведём какой-нибудь класс: 
```c++
struct Noisy {
    Noisy(const Noisy&){
        std::cout << "copy";
    }
    Noisy(){
        std::cout << "created";
    }
    ~Noisy(){
        std::cout << "destroyed";
    }
};
```
Допустим также создана функция, бросающая объект `Noisy`:
```c++
void f() {
    Noisy x;
    throw x;
}
```
Что же выведется после вызова:
```c++
try {
    f();
} catch (const Noisy& x){
    std::cout << "Caught!";
}
```
Будет, кстати, происходить перемещение вместо копирования. 
>Кто не понимает, что я сейчас пишу, забейте (Мещерин) 

Если принимать не по ссылке, а по значению, то будет создана ещё одна копия.
Если запретить конструктор копирования, то бросить не получится. Однако если 
бросить только что созданный объект вот так: 
```c++
throw Noisy();
```
То это сработает, ведь создавать копию не нужно. 

Если внутри блока `catch` вы частично обработали ошибку, то можно вызвать `throw`
без параметров. Это будет означать то, что 
> Вы отпускаете то, что вам прилетело и отправляете его лететь дальше (Мещерин)

Пример кода:
```c++
void g(){
    try {
        throw std::out_of_range("aaa");
    } catch (std::exception& ex ) {
        std::cout << "caught";
        throw;
    }
}

int main() {
    try {
        g();
    } catch (std::out_of_range& oor){
        std::cout << "caught2";
    }
}
```
В приведённом выше коде всё словится хорошо, а если было бы написано `throw ex`, то 
ничего бы не сработало. К сожалению, в плюсах нет `finally` :( 

## Exceptions in constructors and RAII idiom

Представим себе следующую ситуацию:
```c++
void f() {
    int* p = new int(5);

    throw 1;

    delete p;
}

int main() {
    try {
        f();
    } catch (...) {

    }
}
```
Нетрудно заметить в данном коде утечку памяти - ведь `delete` сам за себе не сделается.
Теперь, пусть есть какой-нибудь класс:
```c++
struct S {
    
    int* p = nullptr;

    S() : p(new int(5)){
        throw 1;
    }

    ~S() {
        delete p;
    }
}
```
В таком коде тоже произойдёт утечка памяти:
```c++
try {
    S s;
} catch (...) {

}
```
Теперь вопрос: должен ли вызываться дестрктуор, если исключение было брошено внутри конструктора?
Нет, ведь компилятор не имеет морального права вызвать деструктор до создания объекта. 
> Мораль: исключения в конструкторах - плохо. (Мещерин)

Это проблема. Как решать эту проблему? Умные указатели. Об этом будет отдельная тема позже.
> Resource acquisition is initialization (Какой-то умный чел)

Вы точно знаете, что деструкторы всех локальных объектов будут вызваны до выхода из функции. Поэтому
можно обернуть указатель в объект, в деструкторе которого будет вызываться освобождение памяти. Например, так
```c++
template<typename T>
struct SmartPtr {
    T* ptr = nullptr;
    SmartPtr(T* ptr) : ptr(ptr) {}
    ~SmartPtr() {
        delete ptr;
    }
}
```
Теперь утечек памяти не будет, ведь когда будет вызван деструткор указателя, то память будет освобождена. Ура.
